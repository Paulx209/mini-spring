# [value-annotation Value注解]

Value注解仍然是通过BeanPostProcessor接口的实现类来做的！

1.在扫描@Component包执行完后，将我们的AutowiredAnnotationBeanPostProcessor对象注册到BeanDefinitionMap里面，后续获取到所有的BeanPostProcessors对象的时候，就可以获取到！

2.在Bean实例化完成之后，属性注入之前，会获取到所有的BeanPostProcessor对象，然后判断哪一个是AutowiredAnnotationBeanPostProcessor类型的

3.获取到之后，执行他的postProcessPropertyValues方法，会遍历所有的filed，判断是否添加了@Value注解，但是呢这里的value可能是占位符！

4.所以要对这里的占位符进行处理，因为之前在处理xml配置文件中的占位符时，已经写了相同的逻辑，所以用了一个StringValueResolver对象来复用。（是在xml配置文件占位符处理完毕之后添加进去的）

### 另外

1.新增StringValueResolver接口，添加resolveStringValue()方法

2.ConfigurableBeanFactory类中新增addEmbeddedValueResolver()方法，resolveEmbeddedValue()用于对Value注解中的值做解析！

3.AbstractBeanFactory类用来实现addEmbeddedValueResolver、resolveEmbeddedValue方法




小总结：
截至目前这一章节，现在的生命周期流程已经变成这样子了 ：

### 1.加载BeanDefinition,包扫描！

refresh()方法中的refreshBeanFactory()方法在加载BeanDefinition的时候，会判断xml配置文件中有没有添加<context:component-scan>标签，如果有的话就会执行以下扫描包的逻辑：

首先，创建ClassPathBeanDefinitionScanner类，获取到basePackage包名，执行doScan方法，扫描包下所有添加Component注解的类，然后获取到class对象封装成BeanDefinition

然后，再根据class类判断是否添加scope、component注解上的value属性，如果添加的话需要继续完善BeanDefinition对象。

最后，将beanName和BeanDefinition注册到beanDefinitionMap中。并且还注册了一个AutowiredAnnotationBeanPostProcessor类(这个类则创建代理对象、Value注解)！

注意，这里只是把beanName、Scope获取到了！没有获取到对应Value注解的值！


### 2.执行BeanFactoryPostProcessor，解析占位符！

加载BeanDefinition之后，XML配置文件中的PropertyValue已经加载成功了，但是呢有一些value是替换符，因此我们要借助BeanFactoryPostProcessor接口的实现类，对value里面的内容进行替换，PropertyPlaceholderConfigurer

首先，要加载配置文件properties，然后获取到所有的BeanDefinition，获取到对应的Properties，遍历每一个BeanDefinition中的Property，判断其中的value是否为${xxx}。

然后，如果包括${xxx}的话，直接进行替换即可。

最后，后续处理@Value注解的时候，注解中的value属性中可能会存在${}，所以的话，要将替换占位符的逻辑封装为stringValueResolver对象，并调用addEmbeddedValueResolver方法。


### 3.getBean()方法中，获取代理对象！

获取的时候，先获取bean对应的代理对象，实现的逻辑是这样的：

首先，获取所有的BeanPostProcessor类，然后判断是否存在类型为AutowiredAnnotationBeanPostProcessor的，如果存在的话，调用该类的postProcessBeforeInstantiation的方法

然后，这个方法具体会干什么呢？会获取到配置好的advisor类，然后获取到其中的属性，调用ProxyFactory类获取代理对象！

最后，如果代理对象不为空的话，直接return即可！如果为空的话，再走doCreateBean的逻辑

### 4.bean填充属性之前，修改属性
在对Bean实例的一些属性反射赋值之前，我们需要获取到Bean对应的Class的fields属性中是否添加了@Value注解，如果添加的话，需要对这些字段提前进行反射赋值。

首先，获取到该类对应的所有field字段，然后判断字段上面是否添加了@Value注解，如果添加了的话，就把对用的values()取出来。

然后，取出来之后，直接反射赋值即可。（其实也可以封装成PropertyValue属性交给BeanDefinition，然后在下一步中就会统一进行反射赋值。）