[circular-reference-without-proxy-bean 解决循环依赖问题，没有代理对象]

### 目前的痛点

之前我们涉及到的都是一级缓存，如果出现对象A中存在属性，对象B；对象B中又存在属性，对象A；这样在进行初始化的时候就会出现问题。

对象A实例化，一级缓存中找不到，createBean()，属性注入属性B，getBean(b)；

对象B实例化，一级缓存找不到，createBean()，属性注入A，然后又去A的createBean()

这样就会导致无限次方法调用，栈溢出问题！

所以有一个问题，需要我们考虑，我们bean的存储是在属性注入之前还是属性注入之后？如果是属性注入之后的话，就会有以上说的循环依赖问题！

### 解决方案 -> 二级缓存

如果是属性注入之前的话，那应该放在哪里？其实我们只要bean实例化完成之后，就可以放入map了！ 也就是对象B实例化后，进行属性注入的时候，属性A是是实例化的，而不是初始化的！但是对象A中的属性B是初始化的！

还有一个修改点就是，getSingleton()的时候，一级缓存中如果找不到的话，还要从二级缓存中获取！

二级缓存可以解决普通bean的循环依赖问题，但是对于代理对象的话，可能会导致属性和最后生成的类不一样。

### 仍存在的问题

但是还是会有一个问题，增加二级缓存的话，在遇到代理对象的循环依赖时会遇到一些问题。因为创建代理对象的时机是在BeanPostProcessor的after后置增强中创建的，并且这个代理对象会最终存储到一级缓存中，但是呢我们的实例化之后，就会将对象存储到二级缓存中，这就会导致二级缓存和一级缓存内容不一致！



