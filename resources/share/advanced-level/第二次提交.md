### 问题描述

现在只是用二级缓存的话，会遇到一个问题，我给你举例说明，类A和类B直接互相引用，有属性依赖的关系！
getBean(a)，一级缓存中找不到，二级缓存中找不到，实例化bean，放入二级缓存，属性注入，getBean(b)

一级缓存中找不到，二级缓存中找不到，实例化bean，放入二级缓存，getBean(a)，

一级缓存找不到，二级缓存找到了，进行属性注入，对象b初始化完成。

对象a初始化过程中，会获得到代理对象，最终存入一级缓存的是代理对象！

所以就有一个问题：**对象A，一级缓存是代理对象，二级缓存是普通bean； 对象B，一二级缓存都是普通bean，并且对象B中的属性A是普通bean；就会导致a != b.getA();**

**因为创建代理对象的时机是在BeanPostProcessor的after后置增强中创建的，并且这个代理对象会最终存储到一级缓存中；但是呢二级缓存是在对象实例化之后，存到里面的。**



### 解决方案

在实例化之后，就将代理对象暴露出来！但是暴露出来的代理对象可能是没有属性的！


### 如何解决的？

1。添加三级缓存，在实例化完成之后就将beanName，objectFactory添加到三级缓存中！

2。二级缓存添加bean的时机发生变化，之前是实例化完成就进行添加；现在是在getSingleton()中才会添加进去

3。举例说明

如果是普通bean，没有循环依赖问题的话，在初始化完成之后，会执行getSingleton(beanName)，此时只有三级缓存中存在，然后就会执行getObject()方法，返回一个原始bean，在方法里面添加到二级缓存中，在方法外边添加到一级缓存中；

如果是普通bean，只有单方面依赖的话，比如说a->b，getBean(b)的时候，b直接初始化完成，然后执行getSingleton(b)，更新二级缓存和一级缓存；然后a属性注入完成之后，初始化，最后更新二级缓存和一级缓存！

如果是普通bean，有循环依赖问题，比如说ab互相依赖，在属性注入的时候都要调用getBean(beanName)，因此互相都会提前执行一次三级缓存的getObject()方法，但是返回的都是普通bean


如果是代理对象bean的话，没有循环依赖问题，初始化完成之后，会执行getSingleton(beanName)，此时只有三级缓存存在，执行getObject()方法，返回一个代理对象bean，在方法里面添加到二级缓存中，在方法外边添加到一级缓存中；

如果是代理对象bean的话，只有单方面依赖的问题，比如说a是代理对象，b对象里面有属性a，a在属性注入getBean(b)的时候，b直接初始化完成，然后执行getSingleton(b)，更新二级、一级缓存；然后a属性注入完成之后，初始化，执行三级缓存中getObject()方法，返回一个代理对象，更新二级缓存，然后在方法外边更新一级缓存！

如果是代理对象bean的话，有循环依赖问题，ab互相依赖，a是代理对象。两个在属性注入的时候，都会调用getBean(a/b)，然后会先执行getObject()更新二级缓存！最后在初始化完成之后，再调用一次getBean()方法，更新一级缓存！