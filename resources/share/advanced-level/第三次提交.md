### 【lazy-init-and-multi-advice 懒加载】
如果涉及到的bean非常多的话，在每次启动容器的时候，都需要加载大量的bean，无疑会带来大量的资源浪费。

所以spring呢提供了懒加载模式，对不需要使用的bean设为懒加载，当需要这个bean的时候才进行加载！


### 【lazy-init-and-multi-advice 多个切面匹配同一个方法】

之前在实现AOP的时候，只实现了单个切面的增强，Spring呢是通过拦截器链完成了对多个切面的支持！说一下是如何实现的

### 多切面增强实现逻辑

1.由ProxyFactory的getProxy()方法作为启动入口，getProxy()方法中的createAopProxy()方法会根据属性isProxyTargetClass 或者是否实现接口 来判断走JDK动态代理 or Cglib动态代理

2.然后到getProxy()方法，这个方法是AopProxy接口提供的方法，JdkDynamicAopProxy和CglibAopProxy都实现了这个方法。

JdkDynamicAopProxy通过Proxy.newProxyInstance()方法实现的，需要三个参数，类加载器、共同的接口、InvocationHandler的实现类(调用目标方法时会调用该类中的invoke方法)

CglibAopProxy通过Enhancer类实现，由于Cglib动态代理是通过继承目标类的子类，同样需要三个参数，superClass、interfaces、Callback（可以理解为InvocationHandler，该类中的intercept方法会被调用）

3.获取到代理对象之后，就要开始使用代理对象执行目标方法，

无论是JdkDynamicAopProxy的invoke()方法还是CglibAopProxy的intercept()方法，他们执行逻辑大致都是相同的，首先根据当前的method、class以及advisor来判断有哪些advice增强是要加在该方法上的；

然后将这些参数封装成一个ReflectiveMethodInvocation对象。

最后就是执行这个对象的proceed()方法，根据拦截器链的逻辑，会有一个变量维护当前执行到第几个advice了，如果当前advice是最后一个advice，则调用目标方法，否则调用下一个advice的invoke()方法（补充每一个advice都实现了invoke方法，这个方法会接收一个MethodInvocation类对象，也就是我们之前封装的ReflectiveMethodInvocation对象，可以说这个对象让所有的advice都链接了起来）

### ProxyFactory、AdvicedSupport这些类的关系
1.AdvicedSupport类中包括了MethodMatcher、MethodInterceptor、targetSource、methodCache(缓存用，避免每次执行目标方法时，都需要找对应的advisor)、List<Object> advisors、advisorChainFactory（用于获取advisor集合的）

其中MethodMatcher和Pointcut，用于AspectJ解析；MethodInterceptor用于增强，实现了advice接口，具体的Advice增强就是实现了MethodInterceptor接口，实现其中的invoke方法，这些advice会摘出来封装成一个集合，在ReflectiveMethodInvocation的proceed方法中挨个执行的！

2.我们需要定义AfterReturningAdviceInterceptor类，实现MethodInterceptor接口（相当于实现advice接口），然后将AfterReturningAdvice作为属性，在invoke方法里面执行该类的增强方法
### Q&A
1.如果按照拦截器链的执行顺序的话，那目标方法的调用永远是最后一个，但是After、AfterReturning这些增强是在目标方法执行完毕之后才调用的，这是为什么？

是这样的，这里的实现比较巧妙，像before以及Around这种Advice，他们的invoke方法中会先执行增强的部分，然后在执行methodInvocation.proceed()方法

但是像after以及AfterReturning这种advice，他们的invoke方法中会先执行methodInvocation.proceed()方法，这样就会保证后置一定在原方法之后执行！然后执行完毕之后再回来执行他们自己增强的部分！



